% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/insert_cassette.R
\name{insert_cassette}
\alias{insert_cassette}
\title{Insert a cassette to record an HTTP call}
\usage{
insert_cassette(name, record = "once", match_requests_on = NULL,
  re_record_interval = NULL, tag = NULL, tags = NULL,
  update_content_length_header = FALSE, decode_compressed_response = FALSE,
  allow_playback_repeats = FALSE, allow_unused_http_interactions = TRUE,
  exclusive = FALSE, serialize_with = "yaml", persist_with = "FileSystem",
  preserve_exact_body_bytes = TRUE, ignore_cassettes = TRUE)
}
\arguments{
\item{name}{The name of the cassette. vcr will sanitize this to ensure it is a valid file name.}

\item{record}{The record mode. One of "all", "none", "new_episodes", "once". See Details.}

\item{match_requests_on}{List of request matchers
to use to determine what recorded HTTP interaction to replay. Defaults to
("method", "uri"). The built-in matchers are "method", "uri", "host", "path", "headers"
and "body". You can also pass the name of a registered custom request matcher or
any object that responds to #call.}

\item{re_record_interval}{(integer) When given, the
cassette will be re-recorded at the given interval, in seconds.}

\item{tag}{(character) Used to apply tagged `before_record`
and `before_playback` hooks to the cassette.}

\item{tags}{Used to apply multiple tags to
a cassette so that tagged `before_record` and `before_playback` hooks
will apply to the cassette.}

\item{update_content_length_header}{(logical) Whether or
not to overwrite the Content-Length header of the responses to
match the length of the response body. Defaults to false.}

\item{decode_compressed_response}{(logical) Whether or
not to decode compressed responses before recording the cassette.
This makes the cassette more human readable. Defaults to false.}

\item{allow_playback_repeats}{(logical) Whether or not to
allow a single HTTP interaction to be played back multiple times.
Defaults to false.}

\item{allow_unused_http_interactions}{(logical) If set to
false, an error will be raised if a cassette is ejected before all
previously recorded HTTP interactions have been used.
Defaults to true. Note that when an error has already occurred
(as indicated by the `$!` variable) unused interactions will be
allowed so that we don't silence the original error (which is almost
certainly more interesting/important).}

\item{exclusive}{(logical) Whether or not to use only this
cassette and to completely ignore any cassettes in the cassettes stack.
Default: FALSE.}

\item{serialize_with}{(character) Which serializer to use.
Valid values are "yaml" (default), "syck", "psych", "json" or any registered
custom serializer.}

\item{persist_with}{(character) Which cassette persister to
use. Defaults: "file_system". You can also register and use a
custom persister.}

\item{preserve_exact_body_bytes}{(logical) Whether or not
to base64 encode the bytes of the requests and responses for this cassette
when serializing it. See also `VCR::Configuration#preserve_exact_body_bytes`.}

\item{ignore_cassettes}{(logical) xx. Default: \code{TRUE}}
}
\description{
Insert a cassette to record an HTTP call
}
\examples{
\dontrun{
res <- Cassette$new("foobar")

x <- cassettes()
(cas <- as.cassette(x[[1]]))
as.cassette(cas)
as.cassette(cassettes()[[1]])
as.cassette("foobar")

insert_cassette(name = "fartloud")

use_cassette("foobar", GET("http://google.com"))
}
}
